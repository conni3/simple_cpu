$date
	Fri Aug  8 11:47:19 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module control_tb $end
$var wire 1 ! MemtoReg $end
$var wire 1 " MemWrite $end
$var wire 1 # MemRead $end
$var wire 1 $ Jump $end
$var wire 3 % ImmSrc [2:0] $end
$var wire 1 & BranchSig $end
$var wire 1 ' ALUSrc $end
$var wire 2 ( ALUOp [1:0] $end
$var reg 1 ) ALUimm $end
$var reg 1 * ALUreg $end
$var reg 1 + AUIPC $end
$var reg 1 , Branch $end
$var reg 1 - JAL $end
$var reg 1 . JALR $end
$var reg 1 / LUI $end
$var reg 1 0 Load $end
$var reg 1 1 SYSTEM $end
$var reg 1 2 Store $end
$var reg 32 3 instr [31:0] $end
$var integer 32 4 failed [31:0] $end
$var integer 32 5 passed [31:0] $end
$scope module uut $end
$var wire 1 ) ALUimm $end
$var wire 1 * ALUreg $end
$var wire 1 + AUIPC $end
$var wire 1 , Branch $end
$var wire 1 - JAL $end
$var wire 1 . JALR $end
$var wire 1 / LUI $end
$var wire 1 0 Load $end
$var wire 1 1 SYSTEM $end
$var wire 1 2 Store $end
$var wire 32 6 instr [31:0] $end
$var wire 1 7 funct3 $end
$var parameter 32 8 DATA_WIDTH $end
$var reg 2 9 ALUOp [1:0] $end
$var reg 1 ' ALUSrc $end
$var reg 1 & BranchSig $end
$var reg 3 : ImmSrc [2:0] $end
$var reg 1 $ Jump $end
$var reg 1 # MemRead $end
$var reg 1 " MemWrite $end
$var reg 1 ! MemtoReg $end
$upscope $end
$scope task assert_control $end
$var reg 2 ; exp_ALUOp [1:0] $end
$var reg 1 < exp_ALUSrc $end
$var reg 1 = exp_BranchSig $end
$var reg 3 > exp_ImmSrc [2:0] $end
$var reg 1 ? exp_Jump $end
$var reg 1 @ exp_MemRead $end
$var reg 1 A exp_MemWrite $end
$var reg 1 B exp_MemtoReg $end
$var reg 128 C label [127:0] $end
$upscope $end
$scope task reset_inputs $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100000 8
$end
#0
$dumpvars
bx C
xB
xA
x@
x?
bx >
x=
x<
bx ;
b0 :
b10 9
07
b0 6
b0 5
b0 4
b0 3
02
01
00
0/
0.
0-
0,
0+
1*
0)
b10 (
0'
0&
b0 %
0$
0#
0"
0!
$end
#1000
b10100100010110101110100011110010111000001100101 C
b0 >
b10 ;
0?
0=
0<
0B
0A
0@
#2000
1'
b10 (
b10 9
1)
0*
b1 5
#3000
b10010010010110101110100011110010111000001100101 C
1<
#4000
1!
1#
b0 (
b0 9
1'
10
0)
b10 5
#5000
b1001100011011110110000101100100 C
b0 ;
1B
1@
#6000
b1 %
b1 :
1"
1'
0!
0#
12
00
b11 5
#7000
b101001101110100011011110111001001100101 C
b1 >
0B
1A
0@
#8000
b1 (
b1 9
1&
b10 %
b10 :
0'
0"
1,
02
b100 5
#9000
b10000100111001001100001011011100110001101101000 C
b10 >
b1 ;
1=
0<
0A
#10000
1$
1'
b100 %
b100 :
b0 (
b0 9
0&
1-
0,
b101 5
#11000
b10010100100000101001100 C
b100 >
b0 ;
1?
0=
1<
#12000
b0 %
b0 :
1$
1'
1.
0-
b110 5
#13000
b10010100100000101001100010100100010000001100110011101010110111001100011011101000011001100111101001100000011000000110000 C
b0 >
#14000
b11 %
b11 :
b11 (
b11 9
0$
1'
1/
0.
b111 5
#15000
b10011000101010101001001 C
b11 >
b11 ;
0?
#16000
b11 %
b11 :
b0 (
b0 9
1'
1+
0/
b1000 5
#17000
b100000101010101010010010101000001000011 C
b0 ;
#18000
b1001 5
