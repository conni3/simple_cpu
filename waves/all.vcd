$date
	Mon Jul  7 11:46:11 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module adder_tb $end
$var wire 32 ! result [31:0] $end
$var parameter 32 " WIDTH $end
$var reg 32 # a [31:0] $end
$var reg 32 $ b [31:0] $end
$var integer 32 % failed [31:0] $end
$var integer 32 & passed [31:0] $end
$scope module uut $end
$var wire 32 ' a [31:0] $end
$var wire 32 ( b [31:0] $end
$var wire 32 ) result [31:0] $end
$var parameter 32 * WIDTH $end
$upscope $end
$scope task check $end
$var reg 32 + expected [31:0] $end
$var reg 32 , test_a [31:0] $end
$var reg 32 - test_b [31:0] $end
$upscope $end
$upscope $end
$scope module alu_control_tb $end
$var wire 4 . ALUCtrl [3:0] $end
$var parameter 4 / ALU_ADD $end
$var parameter 4 0 ALU_AND $end
$var parameter 4 1 ALU_LUI $end
$var parameter 4 2 ALU_OR $end
$var parameter 4 3 ALU_SLL $end
$var parameter 4 4 ALU_SLT $end
$var parameter 4 5 ALU_SLTU $end
$var parameter 4 6 ALU_SRA $end
$var parameter 4 7 ALU_SRL $end
$var parameter 4 8 ALU_SUB $end
$var parameter 4 9 ALU_XOR $end
$var reg 2 : ALUOp [1:0] $end
$var reg 3 ; funct3 [2:0] $end
$var reg 1 < funct7_5 $end
$var integer 32 = failed [31:0] $end
$var integer 32 > passed [31:0] $end
$scope module uut $end
$var wire 2 ? ALUOp [1:0] $end
$var wire 3 @ funct3 [2:0] $end
$var wire 1 < funct7_5 $end
$var reg 4 A ALUCtrl [3:0] $end
$upscope $end
$scope task check_output $end
$var reg 4 B actual [3:0] $end
$var reg 4 C expected [3:0] $end
$upscope $end
$upscope $end
$scope module alu_tb $end
$var wire 1 D zero $end
$var wire 32 E alu_result [31:0] $end
$var reg 4 F alu_control [3:0] $end
$var reg 32 G operand_a [31:0] $end
$var reg 32 H operand_b [31:0] $end
$var integer 32 I fail_count [31:0] $end
$var integer 32 J pass_count [31:0] $end
$scope module uut $end
$var wire 4 K alu_control [3:0] $end
$var wire 32 L operand_a [31:0] $end
$var wire 32 M operand_b [31:0] $end
$var wire 1 D zero $end
$var reg 32 N alu_result [31:0] $end
$upscope $end
$scope task do_test $end
$var reg 32 O a [31:0] $end
$var reg 32 P b [31:0] $end
$var reg 4 Q ctrl [3:0] $end
$var reg 32 R expected [31:0] $end
$upscope $end
$upscope $end
$scope module branch_comp_tb $end
$var wire 1 S branch $end
$var reg 3 T funct3 [2:0] $end
$var reg 32 U op1 [31:0] $end
$var reg 32 V op2 [31:0] $end
$var integer 32 W failed [31:0] $end
$var integer 32 X passed [31:0] $end
$scope module uut $end
$var wire 3 Y funct3 [2:0] $end
$var wire 32 Z op1 [31:0] $end
$var wire 32 [ op2 [31:0] $end
$var parameter 3 \ BEQ $end
$var parameter 3 ] BGE $end
$var parameter 3 ^ BGEU $end
$var parameter 3 _ BLT $end
$var parameter 3 ` BLTU $end
$var parameter 3 a BNE $end
$var reg 1 S branch $end
$upscope $end
$scope task check_output $end
$var reg 1 b actual $end
$var reg 1 c expected $end
$upscope $end
$upscope $end
$scope module control_tb $end
$var wire 1 d RegWrite $end
$var wire 1 e MemtoReg $end
$var wire 1 f MemWrite $end
$var wire 1 g MemRead $end
$var wire 1 h Jump $end
$var wire 3 i ImmSrc [2:0] $end
$var wire 1 j Branch $end
$var wire 1 k ALUSrc $end
$var wire 2 l ALUOp [1:0] $end
$var reg 3 m funct3 [2:0] $end
$var reg 7 n opcode [6:0] $end
$var integer 32 o failed [31:0] $end
$var integer 32 p passed [31:0] $end
$scope module uut $end
$var wire 3 q funct3 [2:0] $end
$var wire 7 r opcode [6:0] $end
$var reg 2 s ALUOp [1:0] $end
$var reg 1 k ALUSrc $end
$var reg 1 j Branch $end
$var reg 3 t ImmSrc [2:0] $end
$var reg 1 h Jump $end
$var reg 1 g MemRead $end
$var reg 1 f MemWrite $end
$var reg 1 e MemtoReg $end
$var reg 1 d RegWrite $end
$upscope $end
$scope task check_output $end
$var reg 2 u exp_ALUOp [1:0] $end
$var reg 1 v exp_ALUSrc $end
$var reg 1 w exp_Branch $end
$var reg 3 x exp_ImmSrc [2:0] $end
$var reg 1 y exp_Jump $end
$var reg 1 z exp_MemRead $end
$var reg 1 { exp_MemWrite $end
$var reg 1 | exp_MemtoReg $end
$var reg 1 } exp_RegWrite $end
$upscope $end
$upscope $end
$scope module data_mem_tb $end
$var wire 32 ~ read_data [31:0] $end
$var reg 11 !" addr [10:0] $end
$var reg 1 "" clk $end
$var reg 1 #" we $end
$var reg 32 $" write_data [31:0] $end
$scope module uut $end
$var wire 11 %" addr [10:0] $end
$var wire 1 "" clk $end
$var wire 1 &" re $end
$var wire 1 #" we $end
$var wire 32 '" write_data [31:0] $end
$var reg 32 (" read_data [31:0] $end
$upscope $end
$upscope $end
$scope module imm_gen_tb $end
$var wire 32 )" imm_out [31:0] $end
$var reg 32 *" expected [31:0] $end
$var reg 3 +" imm_sel [2:0] $end
$var reg 32 ," instr [31:0] $end
$var integer 32 -" failed [31:0] $end
$var integer 32 ." passed [31:0] $end
$scope module uut $end
$var wire 3 /" imm_sel [2:0] $end
$var wire 32 0" instr [31:0] $end
$var wire 32 1" u_imm [31:0] $end
$var wire 32 2" s_imm [31:0] $end
$var wire 32 3" j_imm [31:0] $end
$var wire 32 4" i_imm [31:0] $end
$var wire 32 5" b_imm [31:0] $end
$var reg 32 6" imm_out [31:0] $end
$upscope $end
$scope task check $end
$var reg 32 7" exp [31:0] $end
$var reg 3 8" sel [2:0] $end
$var reg 32 9" test_instr [31:0] $end
$upscope $end
$upscope $end
$scope module instr_mem_tb $end
$var wire 32 :" instr [31:0] $end
$var reg 11 ;" addr [10:0] $end
$scope module uut $end
$var wire 11 <" addr [10:0] $end
$var reg 32 =" instr [31:0] $end
$upscope $end
$upscope $end
$scope module mux2_tb $end
$var wire 32 >" y [31:0] $end
$var parameter 32 ?" WIDTH $end
$var reg 32 @" a [31:0] $end
$var reg 32 A" b [31:0] $end
$var reg 1 B" sel $end
$scope module uut $end
$var wire 32 C" a [31:0] $end
$var wire 32 D" b [31:0] $end
$var wire 1 B" sel $end
$var wire 32 E" y [31:0] $end
$var parameter 32 F" WIDTH $end
$upscope $end
$upscope $end
$scope module mux4_tb $end
$var wire 32 G" y [31:0] $end
$var reg 32 H" a [31:0] $end
$var reg 32 I" b [31:0] $end
$var reg 32 J" c [31:0] $end
$var reg 32 K" d [31:0] $end
$var reg 2 L" sel [1:0] $end
$scope module uut $end
$var wire 32 M" a [31:0] $end
$var wire 32 N" b [31:0] $end
$var wire 32 O" c [31:0] $end
$var wire 32 P" d [31:0] $end
$var wire 2 Q" sel [1:0] $end
$var wire 32 R" y [31:0] $end
$var parameter 32 S" WIDTH $end
$upscope $end
$upscope $end
$scope module regfile_tb $end
$var wire 32 T" read_data2 [31:0] $end
$var wire 32 U" read_data1 [31:0] $end
$var reg 1 V" clk $end
$var reg 5 W" next_reg [4:0] $end
$var reg 5 X" read_reg1 [4:0] $end
$var reg 5 Y" read_reg2 [4:0] $end
$var reg 1 Z" regwrite $end
$var reg 1 [" reset $end
$var reg 32 \" write_data [31:0] $end
$var reg 5 ]" write_reg [4:0] $end
$var integer 32 ^" failed [31:0] $end
$var integer 32 _" i [31:0] $end
$var integer 32 `" passed [31:0] $end
$scope module uut $end
$var wire 1 V" clk $end
$var wire 5 a" read_reg1 [4:0] $end
$var wire 5 b" read_reg2 [4:0] $end
$var wire 1 Z" regwrite $end
$var wire 1 [" reset $end
$var wire 32 c" write_data [31:0] $end
$var wire 5 d" write_reg [4:0] $end
$var wire 32 e" read_data2 [31:0] $end
$var wire 32 f" read_data1 [31:0] $end
$var integer 32 g" i [31:0] $end
$upscope $end
$scope task readAndCheck $end
$var reg 5 h" addr1 [4:0] $end
$var reg 5 i" addr2 [4:0] $end
$var reg 32 j" exp1 [31:0] $end
$var reg 32 k" exp2 [31:0] $end
$upscope $end
$scope task writeReg $end
$var reg 5 l" addr [4:0] $end
$var reg 32 m" data [31:0] $end
$upscope $end
$upscope $end
$scope module tb_pc $end
$var wire 32 n" current_pc [31:0] $end
$var reg 1 o" clk $end
$var reg 32 p" next_pc [31:0] $end
$var reg 1 q" reset $end
$scope module uut $end
$var wire 1 o" clk $end
$var wire 32 r" next_pc [31:0] $end
$var wire 1 q" reset $end
$var reg 32 s" current_pc [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100000 S"
b100000 F"
b100000 ?"
b1 a
b110 `
b100 _
b111 ^
b101 ]
b0 \
b101 9
b1 8
b110 7
b111 6
b100 5
b11 4
b10 3
b1000 2
b1010 1
b1001 0
b0 /
b100000 *
b100000 "
$end
#0
$dumpvars
b0 s"
b0 r"
1q"
b0 p"
0o"
b0 n"
bx m"
bx l"
bx k"
bx j"
bx i"
bx h"
bx g"
b0 f"
b0 e"
b0 d"
b0 c"
b0 b"
b0 a"
b0 `"
b100000 _"
b0 ^"
b0 ]"
b0 \"
1["
0Z"
b0 Y"
b0 X"
bx W"
0V"
b0 U"
b0 T"
b1 R"
b0 Q"
b100 P"
b11 O"
b10 N"
b1 M"
b0 L"
b100 K"
b11 J"
b10 I"
b1 H"
b1 G"
b10100101101001011010010110100101 E"
b1011010010110100101101001011010 D"
b10100101101001011010010110100101 C"
0B"
b1011010010110100101101001011010 A"
b10100101101001011010010110100101 @"
b10100101101001011010010110100101 >"
b10011 ="
b0 <"
b0 ;"
b10011 :"
b1111111111100000000000000000000 9"
b0 8"
b11111111111 7"
b11111111111 6"
b11111100000 5"
b11111111111 4"
b111111111110 3"
b11111100000 2"
b1111111111100000000000000000000 1"
b1111111111100000000000000000000 0"
b0 /"
b0 ."
b0 -"
b1111111111100000000000000000000 ,"
b0 +"
bx *"
b11111111111 )"
bx ("
b11011110101011011011111011101111 '"
z&"
b1 %"
b11011110101011011011111011101111 $"
1#"
0""
b1 !"
bx ~
x}
x|
x{
xz
xy
bx x
xw
xv
bx u
b0 t
b10 s
b110011 r
bx q
b0 p
b0 o
b110011 n
bx m
b10 l
0k
0j
b0 i
0h
0g
0f
0e
1d
xc
xb
b10100101101001011010010110100101 [
b10100101101001011010010110100101 Z
b0 Y
b0 X
b0 W
b10100101101001011010010110100101 V
b10100101101001011010010110100101 U
b0 T
1S
b11001 R
b0 Q
b1010 P
b1111 O
b11001 N
b1010 M
b1111 L
b0 K
b0 J
b0 I
b1010 H
b1111 G
b0 F
b11001 E
0D
bx C
bx B
b0 A
b101 @
b0 ?
b0 >
b0 =
1<
b101 ;
b0 :
b0 .
b1 -
b1 ,
b10 +
b10 )
b1 (
b1 '
b0 &
b0 %
b1 $
b1 #
b10 !
$end
#1000
0S
b1 .
b1 A
b10110101101101011011010110110101 V
b10110101101101011011010110110101 [
b1 X
1b
1c
b10 ;
b10 @
b1 :
b1 ?
b1 >
b0 B
b0 C
#2000
b11111111111111111111100000000000 )"
b11111111111111111111100000000000 6"
1S
b0 .
b0 A
b11111111111111111111100000000000 4"
b11111111111111111111100000000000 2"
b11111111111111111111000000000000 5"
b10000000000000000000000000000000 1"
b11111111111100000000000000000000 3"
b1 T
b1 Y
b10110110101101101011011010110110 V
b10110110101101101011011010110110 [
b10 X
0b
0c
0<
b0 ;
b0 @
b10 :
b10 ?
b10 >
b1 B
b1 C
b10000000000000000000000000000000 ,"
b10000000000000000000000000000000 0"
b11111111111111111111100000000000 7"
b10000000000000000000000000000000 9"
b1 ."
b11111111111 *"
b0 !
b0 )
b11111111111111111111111111111111 #
b11111111111111111111111111111111 '
b0 +
b11111111111111111111111111111111 ,
b1 &
#3000
0S
b1 .
b1 A
b10110110101101101011011010110110 U
b10110110101101101011011010110110 Z
b11 X
1b
1c
1<
b11 >
b0 B
b0 C
#4000
b100100011 )"
b100100011 6"
1S
b10 .
b10 A
b100100011 4"
b100100000 2"
b100100000 5"
b10010001100000000000000000000 1"
b100100100010 3"
b100 T
b100 Y
b11111111111111111111111111111011 V
b11111111111111111111111111111011 [
b11111111111111111111111111110110 U
b11111111111111111111111111110110 Z
b100 X
0b
0c
0<
b1 ;
b1 @
b100 >
b1 B
b1 C
b10010001100000000000000000000 ,"
b10010001100000000000000000000 0"
b100100011 7"
b10010001100000000000000000000 9"
b10 ."
b11111111111111111111100000000000 *"
b10000000000000000000000000000000 !
b10000000000000000000000000000000 )
b1111111111111111111111111111111 #
b1111111111111111111111111111111 '
b10000000000000000000000000000000 +
b1111111111111111111111111111111 ,
b10 &
#5000
0S
b11 .
b11 A
b100000 g"
b10 U
b10 Z
b101 X
1b
1c
b10 ;
b10 @
b101 >
b10 B
b10 C
1o"
1V"
1""
#6000
1S
b100 .
b100 A
b100 )"
b100 6"
b0 4"
b100 2"
b100 5"
b1010000000000000 1"
b1010000000000000 3"
b101 T
b101 Y
b11111111111111111111111111110110 V
b11111111111111111111111111110110 [
b11111111111111111111111111111011 U
b11111111111111111111111111111011 Z
b110 X
0b
0c
b11 ;
b11 @
b110 >
b11 B
b11 C
b1 +"
b1 /"
b1010001000100011 ,"
b1010001000100011 0"
b100 7"
b1 8"
b1010001000100011 9"
b11 ."
b100100011 *"
b11111111111111111111111111111111 $
b11111111111111111111111111111111 (
b1111111111111111111111111111111 !
b1111111111111111111111111111111 )
b10000000000000000000000000000000 #
b10000000000000000000000000000000 '
b1111111111111111111111111111111 +
b11111111111111111111111111111111 -
b10000000000000000000000000000000 ,
b11 &
#7000
0S
b101 .
b101 A
b11111111111111111111111111101100 U
b11111111111111111111111111101100 Z
b111 X
1b
1c
b100 ;
b100 @
b111 >
b100 B
b100 C
#8000
0b
0c
b101 B
b101 C
b100 ."
b100 *"
b100 &
