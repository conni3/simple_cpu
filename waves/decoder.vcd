$date
	Tue Aug 26 13:29:42 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module decoder_tb $end
$var wire 1 ! regWrite $end
$var wire 1 " Store $end
$var wire 1 # SYSTEM $end
$var wire 1 $ Load $end
$var wire 1 % LUI $end
$var wire 1 & JALR $end
$var wire 1 ' JAL $end
$var wire 1 ( Branch $end
$var wire 1 ) AUIPC $end
$var wire 1 * ALUreg $end
$var wire 1 + ALUimm $end
$var reg 32 , instr [31:0] $end
$var integer 32 - failed [31:0] $end
$var integer 32 . passed [31:0] $end
$scope module dut $end
$var wire 32 / instr [31:0] $end
$var wire 1 & is_jalr $end
$var wire 1 ! reg_write $end
$var wire 7 0 opcode [6:0] $end
$var wire 1 # is_system $end
$var wire 1 " is_store $end
$var wire 1 % is_lui $end
$var wire 1 $ is_load $end
$var wire 1 ' is_jal $end
$var wire 1 ( is_branch $end
$var wire 1 ) is_auipc $end
$var wire 1 * is_alu_reg $end
$var wire 1 + is_alu_imm $end
$var parameter 32 1 DATA_WIDTH $end
$upscope $end
$scope task check_output $end
$var reg 1 2 exp_ALUimm $end
$var reg 1 3 exp_ALUreg $end
$var reg 1 4 exp_AUIPC $end
$var reg 1 5 exp_Branch $end
$var reg 1 6 exp_JAL $end
$var reg 1 7 exp_JALR $end
$var reg 1 8 exp_LUI $end
$var reg 1 9 exp_Load $end
$var reg 1 : exp_Store $end
$var reg 1 ; exp_regWrite $end
$var reg 32 < instr_val [31:0] $end
$var reg 512 = test_name [511:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100000 1
$end
#0
$dumpvars
b1010010001011010111010001111001011100000110010100111010001000000110000101100100011001000010000001111000001100110010110000100000011110000011000100101100001000000111100000110010 =
b1000001000000110110011 <
1;
0:
09
08
07
06
05
04
13
02
b110011 0
b1000001000000110110011 /
b0 .
b0 -
b1000001000000110110011 ,
0+
1*
0)
0(
0'
0&
0%
0$
0#
0"
1!
$end
#1000
0*
1+
b10011 0
b10100001000000110010011 ,
b10100001000000110010011 /
12
03
b10100001000000110010011 <
b1001001001011010111010001111001011100000110010100111010001000000110000101100100011001000110100100100000011110000011001100101100001000000111100000110001001011000010000000110101 =
b1 .
#2000
0+
1$
b11 0
b10000001010000110000011 ,
b10000001010000110000011 /
19
02
b10000001010000110000011 <
b10011000110111101100001011001000011101000100000011011000111011100100000011110000011001100101100001000000011010000101000011110000011000100101001 =
b10 .
#3000
0!
0$
1"
b100011 0
b1100001010001000100011 ,
b1100001010001000100011 /
0;
1:
09
b1100001010001000100011 <
b1010011011101000110111101110010011001010011101000100000011100110111011100100000011110000011001100101100001000000011010000101000011110000011000100101001 =
b11 .
#4000
1(
0"
b1100011 0
b1100001000000101100011 ,
b1100001000000101100011 /
0:
15
b1100001000000101100011 <
b100001001110010011000010110111001100011011010000011101000100000011000100110010101110001001000000111100000110001001011000010000001111000001100110010110000100000011011110110011001100110011100110110010101110100 =
b100 .
#5000
1!
1&
0(
b1100111 0
b10000001000000111100111 ,
b10000001000000111100111 /
1;
17
05
b10000001000000111100111 <
b100101001000001010011000101001000111010001000000110101001100001011011000111001000100000011110000011001100101100001000000011010000101000011110000011000100101001 =
b101 .
#6000
0&
1'
b1101111 0
b111101111 ,
b111101111 /
07
16
b111101111 <
b1001010010000010100110000111010001000000110101001100001011011000010000001111000001100110010110000100000011011110110011001100110011100110110010101110100 =
b110 .
#7000
1!
0'
1%
b110111 0
b1000110110111 ,
b1000110110111 /
18
06
b1000110110111 <
b100110001010101010010010011101000100000011011000111010101101001001000000111100000110011001011000010000000110001 =
b111 .
#8000
1)
0%
b10111 0
b1000110010111 ,
b1000110010111 /
14
08
b1000110010111 <
b10000010101010101001001010100000100001100111010001000000110000101110101011010010111000001100011001000000111100000110011001011000010000000110001 =
b1000 .
#9000
b1001 .
